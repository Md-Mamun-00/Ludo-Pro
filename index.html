<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Ludo Pro Realtime</title>
    <meta name="theme-color" content="#1f2937">
    <meta name="description" content="Realtime Multiplayer Ludo">
    
    <!-- Libraries -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600;700&display=swap');

        /* Reset & Base */
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        body {
            font-family: 'Fredoka', sans-serif;
            background: #111827; /* gray-900 */
            color: white;
            overflow: hidden;
            touch-action: none;
            height: 100dvh; /* dynamic viewport height */
            width: 100vw;
            margin: 0;
            padding: 0;
        }

        #root { height: 100%; width: 100%; }

        /* Board Container - The Core Responsive Logic */
        .board-container {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 100%;
            padding: 10px;
        }

        .ludo-board {
            display: grid;
            grid-template-columns: repeat(15, 1fr);
            grid-template-rows: repeat(15, 1fr);
            aspect-ratio: 1/1;
            background: white;
            border: 2px solid #333;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            /* Responsive Magic: 95% of whichever is smaller (width or height) */
            width: 95vmin; 
            height: 95vmin;
            max-width: 650px;
            max-height: 650px;
        }

        .cell {
            border: 0.5px solid rgba(0,0,0,0.1);
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* Safe Zones */
        .safe-spot::after {
            content: 'â˜…';
            color: rgba(0,0,0,0.15);
            font-size: 2vmin; /* Responsive font size */
            position: absolute;
            z-index: 0;
        }

        /* 3D Tokens */
        .token {
            width: 80%;
            height: 80%;
            border-radius: 50%;
            position: absolute;
            z-index: 10;
            box-shadow: 
                inset 0 2px 4px rgba(255,255,255,0.4),
                inset 0 -2px 4px rgba(0,0,0,0.2),
                1px 2px 4px rgba(0,0,0,0.4);
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            cursor: pointer;
            border: 1px solid rgba(255,255,255,0.3);
        }

        .token.active-turn {
            animation: bounce 1s infinite;
            filter: brightness(1.2);
            z-index: 20;
            box-shadow: 0 0 10px currentColor;
        }
        
        .token.can-move {
            cursor: pointer;
            animation: pulse-ring 1.5s infinite;
        }

        @keyframes bounce {
            0%, 100% { transform: translateY(0) scale(1); }
            50% { transform: translateY(-15%) scale(1.1); }
        }

        @keyframes pulse-ring {
            0% { box-shadow: 0 0 0 0px currentColor; }
            100% { box-shadow: 0 0 0 6px rgba(255, 255, 255, 0); }
        }

        /* Stacking Logic */
        .stack-2 .token { width: 65%; height: 65%; }
        .stack-3 .token { width: 55%; height: 55%; }
        .stack-4 .token { width: 45%; height: 45%; }
        
        .stack-2 .token:nth-child(1) { transform: translate(-15%, -15%); }
        .stack-2 .token:nth-child(2) { transform: translate(15%, 15%); }

        /* Bases */
        .base-area {
            grid-row: span 6;
            grid-column: span 6;
            padding: 8%;
            border: 2px solid #333;
        }
        .base-inner {
            background: white;
            width: 100%;
            height: 100%;
            border-radius: 15%;
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            padding: 15%;
            gap: 15%;
        }
        .base-spot {
            border-radius: 50%;
            background: rgba(0,0,0,0.05);
            box-shadow: inset 1px 1px 3px rgba(0,0,0,0.2);
        }

        /* Dice Animation */
        .dice-container {
            /* Floating Action Button style on mobile */
            position: relative;
            width: 60px;
            height: 60px;
            z-index: 50;
        }

        .dice-box {
            perspective: 600px;
            width: 100%;
            height: 100%;
        }
        .dice {
            width: 100%;
            height: 100%;
            position: relative;
            transform-style: preserve-3d;
            transition: transform 0.6s cubic-bezier(0.2, 0.8, 0.2, 1);
        }
        .dice-face {
            position: absolute;
            width: 60px;
            height: 60px;
            background: white;
            border: 1px solid #ccc;
            border-radius: 12px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            font-weight: bold;
            color: #333;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.1);
            backface-visibility: hidden;
        }
        .df-1 { transform: rotateY(0deg) translateZ(30px); }
        .df-2 { transform: rotateY(90deg) translateZ(30px); }
        .df-3 { transform: rotateY(180deg) translateZ(30px); }
        .df-4 { transform: rotateY(-90deg) translateZ(30px); }
        .df-5 { transform: rotateX(90deg) translateZ(30px); }
        .df-6 { transform: rotateX(-90deg) translateZ(30px); }

        .rolling {
            animation: roll-dice 0.4s linear infinite;
        }
        @keyframes roll-dice {
            0% { transform: rotateX(0) rotateY(0); }
            100% { transform: rotateX(360deg) rotateY(360deg); }
        }

        /* Emoji Floater */
        .emoji-float {
            position: fixed;
            pointer-events: none;
            animation: floatUp 2.5s ease-out forwards;
            font-size: 3rem;
            z-index: 100;
            text-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }
        @keyframes floatUp {
            0% { transform: translateY(80vh) scale(0.5); opacity: 1; }
            100% { transform: translateY(20vh) scale(1.5); opacity: 0; }
        }

        /* Modal / Overlay */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.8);
            backdrop-filter: blur(5px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 200;
            padding: 20px;
        }

        /* Responsive UI Tweaks */
        @media (min-width: 768px) {
            .ludo-board { border-width: 4px; }
            .base-area { border-width: 4px; }
            .dice-container { width: 80px; height: 80px; }
            .dice-face { width: 80px; height: 80px; font-size: 32px; }
            .df-1 { transform: rotateY(0deg) translateZ(40px); }
            .df-2 { transform: rotateY(90deg) translateZ(40px); }
            .df-3 { transform: rotateY(180deg) translateZ(40px); }
            .df-4 { transform: rotateY(-90deg) translateZ(40px); }
            .df-5 { transform: rotateX(90deg) translateZ(40px); }
            .df-6 { transform: rotateX(-90deg) translateZ(40px); }
        }
    </style>
</head>
<body>

<div id="root"></div>

<script type="text/babel">

// --- Audio System ---
const AudioEngine = {
    ctx: null,
    init: () => {
        if (!AudioEngine.ctx) {
            AudioEngine.ctx = new (window.AudioContext || window.webkitAudioContext)();
        }
        if (AudioEngine.ctx.state === 'suspended') {
            AudioEngine.ctx.resume();
        }
    },
    playTone: (freq, type, duration, vol = 0.1) => {
        if (!AudioEngine.ctx) return;
        const osc = AudioEngine.ctx.createOscillator();
        const gain = AudioEngine.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, AudioEngine.ctx.currentTime);
        gain.gain.setValueAtTime(vol, AudioEngine.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, AudioEngine.ctx.currentTime + duration);
        osc.connect(gain);
        gain.connect(AudioEngine.ctx.destination);
        osc.start();
        osc.stop(AudioEngine.ctx.currentTime + duration);
    },
    roll: () => {
        AudioEngine.init();
        const now = AudioEngine.ctx.currentTime;
        for(let i=0; i<8; i++) {
            setTimeout(() => AudioEngine.playTone(200 + Math.random()*300, 'square', 0.05, 0.05), i*50);
        }
    },
    move: () => {
        AudioEngine.init();
        AudioEngine.playTone(600, 'sine', 0.1);
    },
    capture: () => {
        AudioEngine.init();
        const osc = AudioEngine.ctx.createOscillator();
        const gain = AudioEngine.ctx.createGain();
        osc.frequency.setValueAtTime(800, AudioEngine.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(100, AudioEngine.ctx.currentTime + 0.2);
        gain.gain.setValueAtTime(0.2, AudioEngine.ctx.currentTime);
        gain.gain.linearRampToValueAtTime(0, AudioEngine.ctx.currentTime + 0.2);
        osc.connect(gain);
        gain.connect(AudioEngine.ctx.destination);
        osc.start();
        osc.stop(AudioEngine.ctx.currentTime + 0.2);
    },
    safe: () => {
        AudioEngine.init();
        setTimeout(() => AudioEngine.playTone(400, 'sine', 0.2), 0);
        setTimeout(() => AudioEngine.playTone(600, 'sine', 0.4), 100);
    }
};

// --- Constants ---
const COLORS = {
    RED: '#ef4444',
    GREEN: '#22c55e',
    YELLOW: '#eab308',
    BLUE: '#3b82f6'
};

const PLAYER_ORDER = ['RED', 'GREEN', 'YELLOW', 'BLUE'];

// Visual Grid Mapping (simplified)
const MAIN_PATH_COORDS = [
    [6,1], [6,2], [6,3], [6,4], [6,5],
    [5,6], [4,6], [3,6], [2,6], [1,6], [0,6],
    [0,7], [0,8],
    [1,8], [2,8], [3,8], [4,8], [5,8],
    [6,9], [6,10], [6,11], [6,12], [6,13], [6,14],
    [7,14], [8,14],
    [8,13], [8,12], [8,11], [8,10], [8,9],
    [9,8], [10,8], [11,8], [12,8], [13,8], [14,8],
    [14,7], [14,6],
    [13,6], [12,6], [11,6], [10,6], [9,6],
    [8,5], [8,4], [8,3], [8,2], [8,1], [8,0],
    [7,0], [6,0]
];

const FINAL_PATHS = {
    RED: [[7,1], [7,2], [7,3], [7,4], [7,5], [7,6]],
    GREEN: [[1,7], [2,7], [3,7], [4,7], [5,7], [6,7]],
    YELLOW: [[7,13], [7,12], [7,11], [7,10], [7,9], [7,8]],
    BLUE: [[13,7], [12,7], [11,7], [10,7], [9,7], [8,7]]
};

const SAFE_SPOTS = [0, 8, 13, 21, 26, 34, 39, 47];

// --- Logic ---
function getGlobalPathIndex(color, stepsMoved) {
    if (stepsMoved === 0) return { type: 'base' };
    
    let offset = 0;
    if (color === 'GREEN') offset = 13;
    if (color === 'YELLOW') offset = 26;
    if (color === 'BLUE') offset = 39;

    let totalPos = stepsMoved - 1;
    if (totalPos < 51) {
        let mainIndex = (offset + totalPos) % 52;
        return { type: 'main', index: mainIndex };
    } else {
        let homeIndex = totalPos - 51;
        if (homeIndex > 5) return { type: 'win' };
        return { type: 'home', index: homeIndex };
    }
}

function getCoords(color, stepsMoved, pieceIdx) {
    if (stepsMoved === 0) {
        const bases = {
            RED: [[2,2], [2,3], [3,2], [3,3]],
            GREEN: [[2,11], [2,12], [3,11], [3,12]],
            YELLOW: [[11,11], [11,12], [12,11], [12,12]],
            BLUE: [[11,2], [11,3], [12,2], [12,3]]
        };
        return bases[color][pieceIdx];
    }
    let pos = getGlobalPathIndex(color, stepsMoved);
    if (pos.type === 'main') return MAIN_PATH_COORDS[pos.index];
    if (pos.type === 'home' || pos.type === 'win') {
        let idx = Math.min(pos.index, 5);
        return FINAL_PATHS[color][idx];
    }
    return [7,7];
}

// --- Components ---

const EmojiFloater = ({ emojis }) => (
    <>
        {emojis.map(e => (
            <div key={e.id} className="emoji-float" style={{ left: e.x + '%', top: e.y + '%' }}>
                {e.char}
            </div>
        ))}
    </>
);

const App = () => {
    // State
    const [myId, setMyId] = React.useState(null);
    const [roomCode, setRoomCode] = React.useState('');
    const [isInGame, setIsInGame] = React.useState(false);
    const [isHost, setIsHost] = React.useState(false);
    const [players, setPlayers] = React.useState({}); 
    const [gameState, setGameState] = React.useState({
        turn: 'RED',
        dice: 0,
        pieces: { RED: [0,0,0,0], GREEN: [0,0,0,0], YELLOW: [0,0,0,0], BLUE: [0,0,0,0] },
        winners: []
    });
    const [emojis, setEmojis] = React.useState([]);
    const [micActive, setMicActive] = React.useState(false);
    const [rolling, setRolling] = React.useState(false);
    const [showEmojiMenu, setShowEmojiMenu] = React.useState(false);

    // Refs
    const peerRef = React.useRef(null);
    const connsRef = React.useRef([]);
    
    // Init PeerJS
    React.useEffect(() => {
        const initPeer = () => {
            // Generate simple code
            const id = Math.floor(1000 + Math.random() * 9000).toString(); 
            const peer = new Peer(id);
            
            peer.on('open', (id) => {
                setMyId(id);
                setRoomCode(id);
            });

            peer.on('error', (err) => {
                console.log("Peer Error: ", err);
                if(err.type === 'unavailable-id') initPeer(); 
            });

            peer.on('connection', (conn) => {
                connsRef.current.push(conn);
                setupDataConnection(conn);
            });

            peer.on('call', (call) => {
                navigator.mediaDevices.getUserMedia({ audio: true }).then((stream) => {
                    call.answer(stream); 
                    call.on('stream', (remoteStream) => {
                        const audio = new Audio();
                        audio.srcObject = remoteStream;
                        audio.play();
                    });
                });
            });

            peerRef.current = peer;
        };
        initPeer();
        return () => { if(peerRef.current) peerRef.current.destroy(); };
    }, []);

    // Networking
    const setupDataConnection = (conn) => {
        conn.on('data', (data) => handleData(data, conn.peer));
        conn.on('open', () => { if (isHost) broadcastState(); });
    };

    const handleData = (data, senderId) => {
        if (data.type === 'STATE_UPDATE') {
            setGameState(data.state);
            setPlayers(data.players);
            if(data.sfx) AudioEngine[data.sfx]();
        }
        if (data.type === 'EMOJI') triggerEmoji(data.char);
        
        if (isHost) {
            if (data.type === 'JOIN_REQUEST') {
                const colorsAvailable = PLAYER_ORDER.filter(c => !Object.values(players).find(p => p.color === c));
                const newPlayers = { ...players, [senderId]: { name: `Player ${Object.keys(players).length + 1}`, color: colorsAvailable[0] } };
                setPlayers(newPlayers);
                broadcastState(newPlayers);
            }
            if (data.type === 'ROLL_DICE' && gameState.turn === players[senderId]?.color) performRoll();
            if (data.type === 'MOVE_PIECE' && gameState.turn === players[senderId]?.color) performMove(data.pieceIdx);
        }
    };

    const broadcastState = (updatedPlayers = players, sfx = null) => {
        const payload = { type: 'STATE_UPDATE', state: gameState, players: updatedPlayers, sfx };
        connsRef.current.forEach(conn => conn.send(payload));
        setGameState(gameState);
        setPlayers(updatedPlayers);
        if(sfx) AudioEngine[sfx]();
    };

    // Game Logic (Host)
    const performRoll = () => {
        if (rolling) return;
        setRolling(true);
        AudioEngine.roll();
        
        setTimeout(() => {
            const roll = Math.floor(Math.random() * 6) + 1;
            setRolling(false);
            const newState = { ...gameState, dice: roll };
            
            const playerColor = gameState.turn;
            const pieces = newState.pieces[playerColor];
            const canMove = pieces.some(p => canMovePiece(p, roll));
            
            setGameState(newState);
            
            if (!canMove) {
                broadcastState(players, null);
                setTimeout(() => nextTurn(newState), 800);
            } else {
                broadcastState(players, null);
            }
        }, 600);
    };

    const canMovePiece = (steps, roll) => {
        if (steps === 0 && roll !== 6) return false;
        if (steps + roll > 57) return false;
        return true;
    };

    const performMove = (pieceIdx) => {
        const color = gameState.turn;
        const currentSteps = gameState.pieces[color][pieceIdx];
        const roll = gameState.dice;

        if (!canMovePiece(currentSteps, roll)) return;

        let newSteps = currentSteps === 0 ? 1 : currentSteps + roll;
        let collision = null;
        let sfx = 'move';
        
        const destPos = getGlobalPathIndex(color, newSteps);
        
        // Capture Logic
        if (destPos.type === 'main' && !SAFE_SPOTS.includes(destPos.index)) {
             PLAYER_ORDER.forEach(otherColor => {
                 if (otherColor === color) return;
                 gameState.pieces[otherColor].forEach((s, idx) => {
                     const otherPos = getGlobalPathIndex(otherColor, s);
                     if (otherPos.type === 'main' && otherPos.index === destPos.index) {
                         collision = { color: otherColor, idx: idx };
                     }
                 });
             });
        }

        const newPieces = { ...gameState.pieces };
        newPieces[color] = [...newPieces[color]];
        newPieces[color][pieceIdx] = newSteps;

        if (collision) {
            newPieces[collision.color][collision.idx] = 0; 
            sfx = 'capture';
        } else if (newSteps === 57 || SAFE_SPOTS.includes(destPos.index)) {
            sfx = 'safe';
        }

        const newState = { ...gameState, pieces: newPieces, dice: 0 };
        setGameState(newState);
        
        if (roll === 6 || collision || newSteps === 57) {
            broadcastState(players, sfx);
        } else {
            broadcastState(players, sfx);
            nextTurn(newState);
        }
    };

    const nextTurn = (currentState) => {
        let nextIdx = (PLAYER_ORDER.indexOf(currentState.turn) + 1) % 4;
        let loop = 0;
        while(loop < 4) {
            const nextColor = PLAYER_ORDER[nextIdx];
            if (Object.values(players).find(p => p.color === nextColor)) {
                const newState = { ...currentState, turn: nextColor, dice: 0 };
                setGameState(newState);
                broadcastState(players);
                return;
            }
            nextIdx = (nextIdx + 1) % 4;
            loop++;
        }
    };

    // Interactions
    const handleDiceClick = () => {
        if (!isHost) sendToHost({ type: 'ROLL_DICE' });
        else if (gameState.turn === players[myId]?.color) performRoll();
    };

    const handlePieceClick = (color, idx) => {
        if (gameState.dice === 0) return;
        if (color !== players[myId]?.color) return;
  
